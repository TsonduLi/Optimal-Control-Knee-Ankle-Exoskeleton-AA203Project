# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-UUMTvOFVRYNFl35_glqG0vQYvWZQLg
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline
import jax
import jax.numpy as jnp
import cvxpy as cvx
from scipy.linalg import solve_discrete_are

# Constants
r = 0.05
a = 0.05
b1 = 0.05
b2 = 0.05
b3 = 0.05
l1 = 0.3
l_cm1 = 0.2
I1 = 0.007
I2 = 0.07

def f(s, u, tau1, tau2):
    theta1, theta2, dtheta1, dtheta2 = s
    T1, T2, T3 = u

    ddtheta1 = (1 / I1) * (T1 / r * (b1 * (jnp.sqrt(a**2 + b1**2) + l1 - l_cm1)) / jnp.sqrt(a**2 + b1**2) + tau1)
    ddtheta2 = (1 / I2) * (tau2 - T2 * b2 / r + T3 * b3 / r)
    ds = jnp.array([dtheta1, dtheta2, ddtheta1, ddtheta2])
    s_next = s + 1/total_time_steps * ds
    return s_next

def affinize(f, s, u, tau1, tau2):
    f_su = f(s, u, tau1, tau2)
    A = jax.jacfwd(f, argnums=0)(s, u, tau1, tau2)
    B = jax.jacfwd(f, argnums=1)(s, u, tau1, tau2)
    c = f_su - A @ s - B @ u
    return A, B, c

def do_mpc(x0, x_prev, u_prev, f, P, Q, R, N, rx, ru, rf, x_ref, tau1, tau2):
    n, m = Q.shape[0], R.shape[0]
    x_cvx = cvx.Variable((N + 1, n))
    u_cvx = cvx.Variable((N, m))
    cost = 0.0
    constraints = []
    constraints.append(x_cvx[0] == x0)
    A, B, C = affinize(f, x_prev[-1], u_prev[-1], tau1, tau2)
    P = solve_discrete_are(A,B,Q,R)
    for k in range(N):
        slack_x = cvx.Variable(n)
        slack_u = cvx.Variable(m)
        cost += cvx.quad_form(x_cvx[k] - x_ref[k], Q)
        cost += cvx.norm(slack_x, 1) * 1e4  # Add penalty for slack variable
        if k > 0:
            cost += cvx.quad_form(u_cvx[k] - u_cvx[k - 1], R)
        constraints.append(x_cvx[k + 1] == A @ x_cvx[k] + B @ u_cvx[k] + C)
        constraints.append(x_cvx[k] <= rx + slack_x)
        constraints.append(x_cvx[k, 0:1] >= -slack_x[0])
        constraints.append(u_cvx[k] >= -slack_u)
        constraints.append(u_cvx[k] <= ru + slack_u)
    cost += cvx.quad_form(x_cvx[N] - x_ref[N], P)
    constraints.append(x_cvx[N] <= rf)
    constraints.append(x_cvx[N] >= 0)
    prob = cvx.Problem(cvx.Minimize(cost), constraints)
    prob.solve(solver = cvx.SCS)
    if prob.status != "optimal":
        raise RuntimeError("SCP solve failed. Problem status: " + prob.status)
    x = x_cvx.value
    u = u_cvx.value
    J = prob.objective.value
    status = prob.status
    return x, u, J, status, cost

# Define the critical points for knee flexion
x_critical = np.array([0, 0.14, 0.4, 0.72, 1])
y_critical = np.array([8, 22, 9, 62, 8])
cs_theta1 = CubicSpline(x_critical, y_critical)

x_range_theta1 = np.linspace(0, 1, 500)
y_spline_theta1 = cs_theta1(x_range_theta1)

# Define the critical points for ankle flexion
x_spline_theta2 = np.array([0.63, 0.73, 0.83])
y_spline_theta2 = np.array([0, 12, 0])
cs_theta2 = CubicSpline(x_spline_theta2, y_spline_theta2)

x_range_theta2 = np.linspace(0.63, 0.83, 200)
y_spline_range_theta2 = cs_theta2(x_range_theta2)

num_const_before = 150
num_const_after = 150

x_full_theta2 = np.concatenate([np.linspace(0, 0.63, num_const_before), x_range_theta2, np.linspace(0.83, 1.0, num_const_after)])
y_full_theta2 = np.concatenate([np.zeros(num_const_before), y_spline_range_theta2, np.zeros(num_const_after)])

# Generate reference trajectory
N = 10
total_time_steps = 100
time_steps = np.linspace(0, 1, total_time_steps)

x_ref_full = np.zeros((total_time_steps, 4))
x_ref_full[:, 0] = y_full_theta2[np.linspace(0, 499, total_time_steps, dtype=int)] * np.pi / 180
x_ref_full[:, 1] = cs_theta1(time_steps) * np.pi / 180
vel_1 = np.gradient(x_ref_full[:, 0], time_steps)
vel_2 = np.gradient(x_ref_full[:, 1], time_steps)
x_ref_full[:, 2] = vel_1
x_ref_full[:, 3] = vel_2
acc_1 = np.gradient(vel_1, time_steps)
acc_2 = np.gradient(vel_2, time_steps)

tau1 = acc_1 * I1 + np.random.randn(total_time_steps) * 0.01
tau2 = acc_2 * I2 + np.random.randn(total_time_steps) * 0.01

# MPC parameters
x0 = np.array([0.0, 8/180*np.pi, 0.0, 0.0])
rx = np.array([70 * np.pi / 180, 75 * np.pi / 180, 10, 10])
ru = np.array([100, 100, 100])
rf = np.array([70 * np.pi / 180, 75 * np.pi / 180, 10, 10])
Q = np.eye(4) * 10  # Increase weight for state tracking
R = np.eye(3) * 1   # Decrease weight for control effort
P = np.eye(4)

T = total_time_steps - N
x_mpc = np.zeros((T, N + 1, 4))
u_mpc = np.zeros((T, N, 3))
x = np.copy(x0)

fig, ax = plt.subplots(4, 1, figsize=(12, 18))  # Increase to 4 subplots
dt = 1 / total_time_steps
u_prev = np.zeros((N, 3))
x_prev = np.zeros((N + 1, 4))
for k in range(N):
    x_prev[k + 1] = f(x_prev[k], u_prev[k], tau1[k], tau2[k])

total_cost = 0
tracking_error = np.zeros((T, 4))  # Initialize tracking error array
theta1_vals = np.zeros(T)
theta2_vals = np.zeros(T)
dtheta1_vals = np.zeros(T)
dtheta2_vals = np.zeros(T)

for t in range(T):
    x_ref_segment = x_ref_full[t:t + N + 1]
    x_mpc[t], u_mpc[t], J, status, cost1 = do_mpc(x, x_prev, u_prev, f, P, Q, R, N, rx, ru, rf, x_ref_segment, tau1[t], tau2[t])
    if status == "infeasible":
        x_mpc = x_mpc[:t]
        u_mpc = u_mpc[:t]
        break
    x = f(x, u_mpc[t, 0], tau1[t], tau2[t])
    u_prev = np.concatenate([u_mpc[t, 1:], u_mpc[t, -1:]], axis=0)
    x_prev = np.concatenate([x_mpc[t, 1:], f(x_mpc[t, -1], u_mpc[t, -1], tau1[t], tau2[t])[np.newaxis, :]], axis=0)

    tracking_error[t] = x - x_ref_full[t]  # Calculate tracking error
    theta1_vals[t], theta2_vals[t], dtheta1_vals[t], dtheta2_vals[t] = x[:4]
    total_cost += cost1

print("Total cost = ", total_cost)

# Calculate RMSE for tracking error
rmse_ankle = np.sqrt(np.mean((tracking_error[:, 0] * 180 / np.pi)**2))
rmse_knee = np.sqrt(np.mean((tracking_error[:, 1] * 180 / np.pi)**2))
print(f"RMSE Ankle Angle = {rmse_ankle:.2f} degrees")
print(f"RMSE Knee Angle = {rmse_knee:.2f} degrees")

# Adjust the length of time array to match x_mpc
time = np.linspace(0, (x_mpc.shape[0] + N) * dt, x_mpc.shape[0] + N + 1)

# Plot T1, T2, T3 in a row
fig_torques, ax_torques = plt.subplots(1, 3, figsize=(15, 3))

ax_torques[0].plot(time[:T], u_mpc[:, 0, 0], label="T1")
ax_torques[0].set_title('Torque T1')
ax_torques[0].set_xlabel('Time')
ax_torques[0].set_ylabel('Torque (Nm)')
ax_torques[0].legend()

ax_torques[1].plot(time[:T], u_mpc[:, 0, 1], label="T2")
ax_torques[1].set_title('Torque T2')
ax_torques[1].set_xlabel('Time')
ax_torques[1].set_ylabel('Torque (Nm)')
ax_torques[1].legend()

ax_torques[2].plot(time[:T], u_mpc[:, 0, 2], label="T3")
ax_torques[2].set_title('Torque T3')
ax_torques[2].set_xlabel('Time')
ax_torques[2].set_ylabel('Torque (Nm)')
ax_torques[2].legend()

plt.tight_layout()
plt.savefig("torques.png")
plt.show()

# Plot theta1, theta2, dtheta1, dtheta2
fig_theta, ax_theta = plt.subplots(1, 4, figsize=(15, 4))

ax_theta[0].plot(time[:T], theta1_vals[:T] * 180 / np.pi, label="Theta 1")
ax_theta[0].plot(time_steps[:T], x_ref_full[:T, 0] * 180 / np.pi, label="Reference Theta 1", linestyle='--')
ax_theta[0].set_title('Theta 1')
ax_theta[0].set_xlabel('Time')
ax_theta[0].set_ylabel('Angle (degrees)')
ax_theta[0].legend()

ax_theta[1].plot(time[:T], theta2_vals[:T] * 180 / np.pi, label="Theta 2")
ax_theta[1].plot(time_steps[:T], x_ref_full[:T, 1] * 180 / np.pi, label="Reference Theta 2", linestyle='--')
ax_theta[1].set_title('Theta 2')
ax_theta[1].set_xlabel('Time')
ax_theta[1].set_ylabel('Angle (degrees)')
ax_theta[1].legend()

ax_theta[2].plot(time[:T], dtheta1_vals[:T] * 180 / np.pi, label="dTheta 1")
ax_theta[2].plot(time_steps[:T], x_ref_full[:T, 2] * 180 / np.pi, label="Reference dTheta 1", linestyle='--')
ax_theta[2].set_title('dTheta 1')
ax_theta[2].set_xlabel('Time')
ax_theta[2].set_ylabel('Angular Velocity (degrees/s)')
ax_theta[2].legend()

ax_theta[3].plot(time[:T], dtheta2_vals[:T] * 180 / np.pi, label="dTheta 2")
ax_theta[3].plot(time_steps[:T], x_ref_full[:T, 3] * 180 / np.pi, label="Reference dTheta 2", linestyle='--')
ax_theta[3].set_title('dTheta 2')
ax_theta[3].set_xlabel('Time')
ax_theta[3].set_ylabel('Angular Velocity (degrees/s)')
ax_theta[3].legend()

plt.tight_layout()
plt.savefig("theta_comparison.png")
plt.show()
